<div dir="rtl">

# الدوال والتمرير بالقيمة

## 1️⃣ نظرة عامة على المفهوم

**الدوال (Methods)** هي كتل من الكود تؤدي مهام محددة ويمكن استدعاؤها عند الحاجة. تعزز إعادة استخدام الكود وتنظيمه.

**هيكل الدالة**:
```
معدل_الوصول نوع_الإرجاع اسم_الدالة(قائمة_المعاملات) {
    // جسم الدالة
    return القيمة; // إذا كان نوع_الإرجاع ليس void
}
```

**التمرير بالقيمة (Pass-by-Value)**: Java **دائماً تمرر بالقيمة**. هذا من أكثر المفاهيم سوء فهم في Java.

- للأنواع **البدائية**: تُمرر نسخة من القيمة
- للكائنات **(Objects)**: تُمرر نسخة من المرجع (عنوان الذاكرة)، **وليس** الكائن نفسه

**مهم**: لا يمكنك تغيير ما يشير إليه المرجع من داخل الدالة، لكن يمكنك تعديل حالة الكائن من خلال المرجع.

---

## 2️⃣ لماذا يسأل المحاورون عن هذا

- **اختبار الفهم الأساسي**: كثير من المطورين يعتقدون خطأً أن Java تمرر بالمرجع
- **معرفة نموذج الذاكرة**: يُظهر إذا كنت تفهم كيف تدير Java الذاكرة
- **مصدر أخطاء شائع**: سوء فهم هذا يؤدي لأخطاء في تعديل الكائنات
- **يفصل المتوسط عن المتقدم**: هذا تمييز أساسي يعرفه المطورون ذوو الخبرة
- **تداعيات التصميم**: يؤثر على كيفية تصميم APIs وتوقيعات الدوال

---

## 3️⃣ القواعد والحقائق الأساسية

**قواعد الدوال**:
- اسم الدالة يجب أن يتبع قواعد المعرفات (اتفاقية camelCase)
- نوع الإرجاع إلزامي (استخدم `void` إذا لم يُرجع شيء)
- المعاملات اختيارية (يمكن أن يكون صفر معاملات)
- يمكن زيادة تحميل الدوال (نفس الاسم، معاملات مختلفة)
- الدوال الثابتة (static) تنتمي للفئة؛ دوال النسخة تنتمي للكائنات
- جملة `return` تخرج فوراً من الدالة

**قواعد التمرير بالقيمة**:
- Java **دائماً** تمرر بالقيمة، أبداً بالمرجع
- للأنواع البدائية: تُنسخ القيمة الفعلية
- للكائنات: تُنسخ قيمة المرجع (عنوان الذاكرة)
- لا يمكنك إعادة تعيين معامل مرجع ليشير لكائن مختلف
- يمكنك تعديل حالة الكائن من خلال المرجع
- المصفوفات هي كائنات، فتتبع قواعد مراجع الكائنات

**قواعد زيادة التحميل (Overloading)**:
- نفس اسم الدالة، قائمة معاملات مختلفة (النوع، العدد، أو الترتيب)
- نوع الإرجاع وحده ليس كافياً لزيادة التحميل
- معدل الوصول يمكن أن يكون مختلفاً
- المترجم يختار الدالة وقت الترجمة بناءً على المعاملات
- تُختار الدالة الأكثر تحديداً على الأقل تحديداً (التوسيع مقابل autoboxing)

**المعاملات المتغيرة (Varargs)**:
- الصيغة: `type... variableName`
- يجب أن يكون المعامل الأخير
- يُعامل كمصفوفة داخل الدالة
- يمكن أن يكون معامل varargs واحد فقط لكل دالة

---

## 4️⃣ أمثلة برمجية (Java 8)

### المثال 1: التمرير بالقيمة مع الأنواع البدائية

```java
public class PassByValuePrimitive {
    public static void modifyPrimitive(int num) {
        num = 100;  // تُغير النسخة المحلية فقط
        System.out.println("Inside method: " + num);  // 100
    }

    public static void main(String[] args) {
        int value = 10;
        modifyPrimitive(value);
        System.out.println("After method: " + value);  // 10 (لم تتغير)

        // التفسير: تُمرر نسخة من 'value' للدالة.
        // الدالة تُعدل نسختها المحلية، وليس الأصلية.
    }
}
```

**الناتج**:
```
Inside method: 100
After method: 10
```

### المثال 2: التمرير بالقيمة مع الكائنات (الجزء المخادع)

```java
class Person {
    String name;

    Person(String name) {
        this.name = name;
    }
}

public class PassByValueObject {
    // تعديل حالة الكائن - يعمل
    public static void modifyObjectState(Person p) {
        p.name = "Modified";  // يُغير حالة الكائن
        System.out.println("Inside method: " + p.name);  // Modified
    }

    // إعادة تعيين المرجع - لا يعمل
    public static void reassignReference(Person p) {
        p = new Person("New Person");  // يُغير النسخة المحلية من المرجع فقط
        System.out.println("Inside method: " + p.name);  // New Person
    }

    public static void main(String[] args) {
        // الاختبار 1: تعديل حالة الكائن
        Person person1 = new Person("John");
        modifyObjectState(person1);
        System.out.println("After modifyObjectState: " + person1.name);  // Modified

        System.out.println("---");

        // الاختبار 2: إعادة تعيين المرجع
        Person person2 = new Person("Alice");
        reassignReference(person2);
        System.out.println("After reassignReference: " + person2.name);  // Alice (لم تتغير!)

        /*
         * التفسير:
         * - person1 و p (في الدالة) كلاهما يشيران لنفس الكائن في البداية
         * - التعديل من خلال p يؤثر على الكائن الفعلي
         * - إعادة تعيين p يُنشئ كائناً جديداً، لكن person1 لا تزال تشير للأصلي
         * - قيمة المرجع تُنسخ، وليس المرجع نفسه
         */
    }
}
```

**الناتج**:
```
Inside method: Modified
After modifyObjectState: Modified
---
Inside method: New Person
After reassignReference: Alice
```

### المثال 3: التمرير بالقيمة مع المصفوفات

```java
public class PassByValueArray {
    public static void modifyArray(int[] arr) {
        arr[0] = 999;  // يُعدل المصفوفة الأصلية
        System.out.println("Inside method, arr[0]: " + arr[0]);  // 999
    }

    public static void reassignArray(int[] arr) {
        arr = new int[]{100, 200, 300};  // مصفوفة جديدة، لا تؤثر على الأصلية
        System.out.println("Inside method, arr[0]: " + arr[0]);  // 100
    }

    public static void main(String[] args) {
        int[] numbers = {1, 2, 3};

        modifyArray(numbers);
        System.out.println("After modifyArray, numbers[0]: " + numbers[0]);  // 999

        reassignArray(numbers);
        System.out.println("After reassignArray, numbers[0]: " + numbers[0]);  // 999 (لم تتغير)
    }
}
```

**الناتج**:
```
Inside method, arr[0]: 999
After modifyArray, numbers[0]: 999
Inside method, arr[0]: 100
After reassignArray, numbers[0]: 999
```

### المثال 4: زيادة تحميل الدوال (Method Overloading)

```java
public class MethodOverloading {
    // دوال متزايدة التحميل: نفس الاسم، معاملات مختلفة

    public int add(int a, int b) {
        return a + b;
    }

    public double add(double a, double b) {
        return a + b;
    }

    public int add(int a, int b, int c) {
        return a + b + c;
    }

    public String add(String a, String b) {
        return a + b;
    }

    public static void main(String[] args) {
        MethodOverloading obj = new MethodOverloading();

        System.out.println(obj.add(5, 10));           // 15 (نسخة int)
        System.out.println(obj.add(5.5, 10.5));       // 16.0 (نسخة double)
        System.out.println(obj.add(1, 2, 3));         // 6 (نسخة ثلاثة int)
        System.out.println(obj.add("Hello", "World")); // HelloWorld (نسخة String)
    }
}
```

### المثال 5: المعاملات المتغيرة (Varargs)

```java
public class VarargsDemo {
    // Varargs: يمكن قبول 0 أو أكثر من المعاملات
    public static int sum(int... numbers) {
        int total = 0;
        for (int num : numbers) {
            total += num;
        }
        return total;
    }

    // Varargs يجب أن يكون المعامل الأخير
    public static void display(String message, int... numbers) {
        System.out.print(message + ": ");
        for (int num : numbers) {
            System.out.print(num + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        System.out.println(sum());              // 0 (بدون معاملات)
        System.out.println(sum(5));             // 5 (معامل واحد)
        System.out.println(sum(1, 2, 3, 4));   // 10 (معاملات متعددة)

        // يمكن أيضاً تمرير مصفوفة
        int[] nums = {10, 20, 30};
        System.out.println(sum(nums));          // 60

        display("Numbers", 1, 2, 3, 4, 5);     // Numbers: 1 2 3 4 5
    }
}
```

### المثال 6: أنواع الإرجاع وتسلسل الدوال

```java
class Calculator {
    private int value;

    public Calculator setValue(int value) {
        this.value = value;
        return this;  // أرجع 'this' لتسلسل الدوال
    }

    public Calculator add(int num) {
        this.value += num;
        return this;
    }

    public Calculator multiply(int num) {
        this.value *= num;
        return this;
    }

    public int getValue() {
        return this.value;
    }
}

public class MethodChaining {
    public static void main(String[] args) {
        Calculator calc = new Calculator();

        // تسلسل الدوال (واجهة سلسة)
        int result = calc.setValue(10)
                         .add(5)
                         .multiply(2)
                         .getValue();

        System.out.println(result);  // 30 [(10 + 5) * 2]
    }
}
```

### المثال 7: الدوال الثابتة مقابل دوال النسخة

```java
class MathUtils {
    // دالة ثابتة - تنتمي للفئة
    public static int square(int num) {
        return num * num;
    }

    // دالة نسخة - تنتمي للكائن
    private int multiplier = 2;

    public int multiply(int num) {
        return num * multiplier;
    }
}

public class StaticVsInstance {
    public static void main(String[] args) {
        // الدالة الثابتة - تُستدعى على الفئة
        int squared = MathUtils.square(5);
        System.out.println(squared);  // 25

        // دالة النسخة - تتطلب كائناً
        MathUtils utils = new MathUtils();
        int multiplied = utils.multiply(5);
        System.out.println(multiplied);  // 10

        // يمكن استدعاء الدالة الثابتة على كائن (غير مُوصى به)
        // int squared2 = utils.square(5);  // يعمل لكنه مربك
    }
}
```

---

## 5️⃣ أسئلة المقابلات الشائعة

1. **هل Java تمرير بالقيمة أم تمرير بالمرجع؟**
2. **اشرح بمثال لماذا Java تمرير بالقيمة للكائنات.**
3. **هل يمكنك تغيير قيمة نوع بدائي مُمرر لدالة؟**
4. **ما هو زيادة تحميل الدوال؟ ما هي القواعد؟**
5. **هل يمكننا زيادة تحميل الدوال بتغيير نوع الإرجاع فقط؟**
6. **ما الفرق بين الدوال الثابتة ودوال النسخة؟**
7. **ما هي varargs؟ ما هي قواعد استخدامها؟**
8. **هل يمكن للدالة أن يكون لها عدة جمل return؟**
9. **ماذا يحدث إذا لم تُرجع قيمة في دالة غير void؟**
10. **لماذا لا يمكنك تعديل ما يشير إليه معامل مرجع؟**

---

## 6️⃣ إجابات نموذجية

**س1: هل Java تمرير بالقيمة أم تمرير بالمرجع؟**

"Java دائماً تمرير بالقيمة، بشكل صارم. للأنواع البدائية، القيمة الفعلية تُنسخ وتُمرر. للكائنات، قيمة المرجع—وهي عنوان الذاكرة—تُنسخ وتُمرر. هذا يعني أنك تستقبل نسخة من المرجع، وليس المرجع نفسه. لذا يمكنك تعديل حالة الكائن من خلال المرجع، لكن لا يمكنك جعل المرجع الأصلي يشير لكائن مختلف."

**س2: اشرح بمثال لماذا Java تمرير بالقيمة للكائنات.**

"دعني أعطيك مثالاً واضحاً. إذا كان لدي كائن Person ومررته لدالة، كل من المتغير الأصلي والمعامل يشيران لنفس الكائن. إذا عدّلت الدالة خصائص الكائن، هذه التغييرات مرئية لأنها تُعدل نفس الكائن. ومع ذلك، إذا حاولت الدالة إعادة تعيين المعامل لكائن جديد بـ 'p = new Person()'، هذا يُغير فقط النسخة المحلية من المرجع. المتغير الأصلي لا يزال يشير للكائن الأصلي. إذا كانت Java تمرير بالمرجع، إعادة تعيين المعامل ستُغير أيضاً ما يشير إليه المتغير الأصلي، لكن هذا لا يحدث."

**س3: هل يمكنك تغيير قيمة نوع بدائي مُمرر لدالة؟**

"لا، لا يمكنك تغيير قيمة النوع البدائي الأصلية من داخل الدالة. عندما تمرر نوعاً بدائياً لدالة، تُنشأ نسخة من تلك القيمة. أي تعديلات داخل الدالة تؤثر فقط على النسخة المحلية، وليس المتغير الأصلي. المتغير الأصلي يبقى بدون تغيير بعد عودة الدالة."

**س4: ما هو زيادة تحميل الدوال؟ ما هي القواعد؟**

"زيادة تحميل الدوال هو وجود عدة دوال بنفس الاسم لكن قوائم معاملات مختلفة في نفس الفئة. يمكن أن تختلف قائمة المعاملات في عدد المعاملات، أنواعها، أو ترتيبها. نوع الإرجاع وحده ليس كافياً لزيادة التحميل. المترجم يُحدد أي دالة يستدعي بناءً على المعاملات المُقدمة وقت الترجمة. هذا يُسمى أيضاً تعدد الأشكال وقت الترجمة أو تعدد الأشكال الثابت."

**س5: هل يمكننا زيادة تحميل الدوال بتغيير نوع الإرجاع فقط؟**

"لا، لا يمكنك زيادة تحميل الدوال بتغيير نوع الإرجاع فقط. توقيع الدالة يتضمن اسم الدالة وقائمة المعاملات، لكن ليس نوع الإرجاع. إذا كان لدالتين نفس الاسم والمعاملات لكن أنواع إرجاع مختلفة، المترجم لن يستطيع التمييز بينهما بناءً على استدعاء الدالة، مما يؤدي لخطأ ترجمة. ومع ذلك، يمكن أن يكون لديك أنواع إرجاع مختلفة طالما قوائم المعاملات مختلفة."

**س6: ما الفرق بين الدوال الثابتة ودوال النسخة؟**

"الدوال الثابتة تنتمي للفئة ويمكن استدعاؤها بدون إنشاء كائن. يمكنها الوصول فقط للأعضاء الثابتة مباشرة. دوال النسخة تنتمي للكائنات وتتطلب كائناً لاستدعائها. يمكنها الوصول لكل من الأعضاء الثابتة وأعضاء النسخة. الدوال الثابتة مفيدة للدوال المساعدة التي لا تحتاج حالة الكائن، بينما دوال النسخة عادة تعمل مع بيانات خاصة بالكائن. الدوال الثابتة لا يمكنها استخدام كلمة 'this' لأنها غير مرتبطة بأي نسخة."

**س7: ما هي varargs؟ ما هي قواعد استخدامها؟**

"Varargs، أو المعاملات المتغيرة، تسمح للدالة بقبول صفر أو أكثر من المعاملات من نوع محدد. تُعلن باستخدام ثلاث نقاط بعد النوع، مثل 'int... numbers'. داخل الدالة، تُعامل varargs كمصفوفة. القواعد الأساسية: varargs يجب أن تكون المعامل الأخير في توقيع الدالة، يمكن أن يكون لديك معامل varargs واحد فقط لكل دالة، ويمكنك تمرير صفر أو أكثر من المعاملات أو حتى مصفوفة مباشرة."

**س8: هل يمكن للدالة أن يكون لها عدة جمل return؟**

"نعم، يمكن للدالة أن يكون لها عدة جمل return، لكن واحدة فقط ستُنفذ لأي استدعاء دالة معين. هذا يُستخدم بشكل شائع في المنطق الشرطي حيث مسارات مختلفة تُرجع قيماً مختلفة. ومع ذلك، جميع مسارات التنفيذ الممكنة يجب أن تنتهي بجملة return للدوال غير void، وإلا المترجم سيُلقي خطأ عن جمل return مفقودة."

**س9: ماذا يحدث إذا لم تُرجع قيمة في دالة غير void؟**

"إذا لم تُرجع دالة غير void قيمة في جميع مسارات التنفيذ الممكنة، الكود لن يُترجم. المترجم يُجري تحليل التدفق لضمان أن كل مسار عبر الدالة ينتهي بجملة return من النوع الصحيح. هذا خطأ وقت ترجمة، وليس خطأ وقت تشغيل، مما يساعد في اكتشاف الأخطاء مبكراً."

**س10: لماذا لا يمكنك تعديل ما يشير إليه معامل مرجع؟**

"لأن Java تمرر قيمة المرجع، وليس المرجع نفسه. عندما تمرر كائناً لدالة، أنت تمرر نسخة من عنوان الذاكرة. معامل الدالة والمتغير الأصلي كلاهما يشيران لنفس الكائن، لكنهما متغيران منفصلان. إذا أعدت تعيين المعامل ليشير لكائن جديد، أنت تُغير فقط النسخة المحلية من المرجع. المتغير الأصلي لا يزال يحمل قيمة المرجع الأصلية. إنه مثل وجود جهازي تحكم عن بعد يشيران لنفس التلفاز—تغيير أي تلفاز يشير إليه أحدهما لا يؤثر على الآخر."

---

## 7️⃣ الأخطاء الشائعة

1. **الاعتقاد بأن Java تمرير بالمرجع للكائنات**:
   ```java
   void swap(Person p1, Person p2) {
       Person temp = p1;
       p1 = p2;
       p2 = temp;
   }
   // هذا لا يُبدل المراجع الأصلية!
   ```

2. **محاولة زيادة التحميل بناءً على نوع الإرجاع فقط**:
   ```java
   int getValue() { return 10; }
   String getValue() { return "10"; }  // خطأ ترجمة!
   ```

3. **نسيان أن المصفوفات هي كائنات**:
   ```java
   void modify(int[] arr) {
       arr = new int[]{100};  // لا تُغير مرجع المصفوفة الأصلية
   }
   ```

4. **وضع varargs قبل معاملات أخرى**:
   ```java
   void method(int... nums, String str) { }  // خطأ ترجمة!
   // صحيح: void method(String str, int... nums) { }
   ```

5. **return مفقود في جميع مسارات الكود**:
   ```java
   int getValue(boolean flag) {
       if (flag) {
           return 10;
       }
       // خطأ ترجمة: جملة return مفقودة
   }
   ```

6. **افتراض أن الدالة يمكنها تعديل معامل بدائي**:
   ```java
   void increment(int x) {
       x++;  // تُعدل النسخة المحلية فقط
   }
   ```

7. **الخلط في سياق الدالة الثابتة**:
   ```java
   class MyClass {
       int instanceVar = 10;

       static void staticMethod() {
           System.out.println(instanceVar);  // خطأ ترجمة!
           // الدوال الثابتة لا يمكنها الوصول لمتغيرات النسخة مباشرة
       }
   }
   ```

8. **معامل مرجع null**:
   ```java
   void modify(Person p) {
       p.name = "John";  // NullPointerException إذا كانت p null
   }
   // دائماً تحقق من null إذا كان المعامل قد يكون null
   ```

---

## 8️⃣ نصائح من المقابلات الفعلية

**ما يجب التأكيد عليه**:
- Java دائماً تمرير بالقيمة (هذا حاسم)
- للكائنات، نمرر قيمة المرجع، وليس المرجع نفسه
- يمكنك تعديل حالة الكائن لكن ليس ما يشير إليه المرجع
- ارسم مخططات توضح الذاكرة/المراجع إذا لزم الأمر
- زيادة تحميل الدوال هو تعدد أشكال وقت الترجمة

**ما يجب تجنبه**:
- لا تقل أبداً "Java تمرير بالمرجع للكائنات"
- لا تخلط بين تعديل حالة الكائن وتغيير المرجع
- لا تدّعِ أن نوع الإرجاع جزء من توقيع الدالة لزيادة التحميل
- تجنب القول "varargs هي مصفوفة" (تُعامل كواحدة، لكن الصيغة تختلف)

**تحت الضغط**:
- إذا سُئلت عن التمرير بالقيمة مقابل التمرير بالمرجع، ارسم صندوقين: واحد للمتغير الأصلي وواحد لمعامل الدالة، كلاهما يشير لنفس الكائن
- لمثال swap، اشرح لماذا لا يعمل (يُغير النسخ المحلية فقط)
- استخدم عبارة "نسخة من المرجع" لتوضيح تمرير الكائنات

**علامات التحذير التي يجب تجنبها**:
- "Java لديها تمرير بالمرجع" (غير صحيح)
- "الكائنات تُمرر بالمرجع" (غير دقيق—قيم المراجع تُمرر)
- "لا يمكنك تعديل الكائنات في الدوال" (يمكنك تعديل الحالة)
- "الدوال الثابتة أسرع" (ليس اعتباراً تصميمياً)

**نقاط إضافية**:
- اذكر أن String غير قابل للتغيير، فالتعديلات تُنشئ كائنات جديدة
- ناقش زيادة تحميل الدوال مقابل إعادة التعريف (التحميل وقت ترجمة، إعادة التعريف وقت تشغيل)
- أشر لغموض varargs عند زيادة تحميل الدوال
- اشرح أن فئات الغلاف غير قابلة للتغيير مثل String
- اذكر مثال StringBuilder حيث يمكنك التعديل داخل الدوال (لأنك تُعدل حالة الكائن)

</div>
